<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <title>The Case for Data Package Managers - juan.benet.ai</title>
  <meta name="viewport" content="width=device-width">

  <!-- CSS -->
  <link href="//netdna.bootstrapcdn.com/bootstrap/3.0.0/css/bootstrap.min.css" rel="stylesheet" />
  <link href="//netdna.bootstrapcdn.com/font-awesome/3.2.1/css/font-awesome.min.css" rel="stylesheet" />
  <link rel="stylesheet" href="/css/syntax.css">
  <link href="/css/main.css" media="all" rel="stylesheet" type="text/css" />

  <!-- jQuery for inlined $ -->
  <script src="//ajax.googleapis.com/ajax/libs/jquery/1.10.2/jquery.min.js" ></script>

</head>
<body>

<div class="site">

  <div class="content markdown">
  <h2>
  <small><a href="/">Juan Benet</a> /
  <a class="category" href="/data">
  data</a> /</small>
  The Case for Data Package Managers</h2>
<p class="meta">2014-03-04</p>

<div class="post">
<p><a href="/data/2014-02-21/data-management-problems">Numerous problems plague data sharing today</a>. This post proposes Package Management as the foundation to address them. Note: to make sure we&#39;re on the same page semantically, check my <a href="/data/2014-02-21/data-management-vocabulary">data vocabulary</a>.</p>

<div class="align-center">
<img src="http://jbenet.static.s3.amazonaws.com/51cd6a8/data-flap.png" />
</div>

<h2 id="package-managers">Package Managers</h2>

<blockquote>
<p>In software, a package management system, also called package manager, is a collection of software tools to automate the process of installing, upgrading, configuring, and removing software packages for a computer&#39;s operating system in a consistent manner. It typically maintains a database of software dependencies and version information to prevent software mismatches and missing prerequisites. <small class="align-right">From <a href="http://en.wikipedia.org/wiki/Package_management_system">Package Management System (Wikipedia)</a>.</small></p>
</blockquote>

<p>Package managers have been hailed among <a href="http://ianmurdock.com/solaris/how-package-management-changed-everything/">the most important innovations</a> Linux brought to the computing industry. They greatly simplified and improved software distribution. By versioning, carefully bookkeeping, and maintaining centralized repositories, the various linux communities built robust and usable systems.</p>

<p>For end users, Package Managers automated software installation (adding, upgrading, and removing programs). Typical installation meant having to manually (1) find and download archives, (2) compile binaries (which often failed), (3) move files to their destination, and -- worst of all -- (4) repeat for all dependencies, and dependencies of dependencies. Package managers automated the process into one command: <code>pkgmgr install package-name</code>. Uninstalling software (reverting  installation, often undocumented) became similarly simple: <code>pkgmgr uninstall package-name</code>. Users no longer had to search the web for the compatible versions of programs, walk trees of dependencies, wrestle with compilers, and hope that everything interoperated just right. Instead, users could rely on common programs being versioned, listed, and properly packaged for their systems.</p>

<p>For software authors, Package Managers automated software distribution (packaging, hosting, and disseminating). Before, programmers would have to create bundles of their source code with (often complicated) installation instructions. Though conventions existed (include a <code>Makefile</code>, <code>README</code>, and <code>LICENSE</code>), installation and its documentation were confusing hurdles that harmed the adoption of programs. Additionally, authors had to find a reliable way to transfer the files to end users, which usually meant having to create and maintain a website. If the website failed, the package (and its dependents) would not be installable. Package managers host all files in a central repository and are mirrored for redundancy, which significantly increases the availability of packages and reduces the authors&#39; time and money costs. While packaging across platforms varies from <a href="http://gist.io/1318304">simple</a> to <a href="http://www.debian.org/doc/manuals/packaging-tutorial/packaging-tutorial.en.pdf">complex</a>, it is standardized and well worth it for software authors.</p>

<h2 id="solving-data-problems">Solving Data Problems</h2>

<p>The activities of both publishers and users of datasets resemble those of authors and users of software packages. Moreover, the problems I presented in <a href="/data/2014-02-21/data-management-problems"><em>Data Management Problems</em></a> are precisely the kind of problems package managers solved for software. Below I outline how package managers can also solve them for data; though each issue is large and worth addressing at length in the future. The takeaway is this:</p>

<blockquote>
<p>(1) A Package Manager can solve our Data Management problems.</p>
</blockquote>

<h3 id="distribution">Distribution</h3>

<p>Package Managers generally use centralized repositories to store and distribute their packages. Individual publishers simply upload their files to the repository, offloading the costs of distribution to the network&#39;s infrastructure. This substantially reduces publishing friction, as individuals no longer need to worry about setting up their own websites, paying for distribution themselves, or sourcing funding. It also <em>reduces overall costs</em>, by pooling network resources.</p>

<h4 id="amortizing-distribution-costs">Amortizing Distribution Costs</h4>

<p>Monetary costs are certainly still an issue, but an organization setup with the explicit goal of managing and distributing large datasets is better equipped to handle them than individual dataset authors. By pooling the resources and efforts of interested individuals (engineers, admins, etc), such an organization can better:</p>

<ol>
<li>Attract and secure funding, such as grants or <a href="http://en.wikipedia.org/wiki/Crowdfunding">crowdfunding</a>.</li>
<li>Design and implement complex technical solutions to reduce costs.</li>
<li>Simplify the publishing process with tools addressing common pain points.</li>
</ol>

<blockquote>
<p>(2) A Data Package Manager would amortize distribution costs.</p>
</blockquote>

<h3 id="indexing">Indexing</h3>

<p>Indexing is the raison d&#39;etre of package managers. They are designed precisely to provide central access points where all packages can be found. By collecting domain-specific meta-data, package managers allow efficient and programmable search for packages. For example, in our dataset case, consider collecting dataset meta-data such as the (a) title, (b) research fields, (c) file formats, (d) abstract, (e) relevant keywords, (f) relevant publications, (g) license, (h) sources, (i) authors, and (j) publication date. A central index of this information would provide powerful and precise search of available datasets. It would also standardize the meta-data requirements, ensure publishers provide it, and allow users to view it.</p>

<blockquote>
<p>(3) A Data Package Manager would index and search datasets.</p>
</blockquote>

<h3 id="permanence">Permanence</h3>

<p>As <a href="/data/2014-02-21/data-management-problems%7D">discussed previously</a>,  once published, datasets must not disappear. All publications -- paper or data -- must be available indefinitely. When do we know something is completely and utterly unnecessary anymore, even to historians of a field? Never. Thus, it is important to store <em>all</em> our data -- as we store papers and code. Package managers in software already do this, as it is never clear when an old package will be required. Our Data Package Manager is no different; all datasets would be retrievable at any point in the future, as long as the package manager itself survives. Additionally, as the amount of valuable data stored by the package manager increases, so do the incentives to maintain it. In a sense, by storing all the important datasets together, we increase the survival chances of the whole repository.<sup id="fnref1"><a href="#fn1" rel="footnote">1</a></sup></p>

<blockquote>
<p>(4) A Data Package Manager would provide datasets permanently.</p>
</blockquote>

<h3 id="versioning">Versioning</h3>

<p>The need for versioning data is clear. Datasets change over time, often after being shared with others or published broadly. It is critical to track and provide access to these changes, or at least to the different published versions. Regardless of correctness or currency, <em>all</em> versions must be kept available; future work will often seek to understand or compare previous work done with previous dataset versions. To stress the point, <strong>for the sake of the scientific enterprise and data work in general, we must track and distribute all versions of datasets</strong>.</p>

<blockquote>
<p>(5) A Data Package Manager would provide all versions of datasets.</p>
</blockquote>

<h4 id="version-control-systems-for-data">Version Control Systems for Data</h4>

<p>But how exactly to version data is a complex question. To date, there is no single Version Control System capable of handling datasets as well as <a href="http://git-scm.com/" title="Git">git</a> handles source code. Unlike code, which is plain text, datasets come in a tremendous variety of formats. Version efforts that assume datasets will follow certain properties (e.g. small size, plaintext format) are bound to be limited in scope. Perhaps this is acceptable, as format-specific VCSes can provide great domain-specific functionality. Or perhaps one VCS could be built to easily accomodate domain-specific extensions.<sup id="fnref2"><a href="#fn2" rel="footnote">2</a></sup> This will be the subject of a future post. For now, let us separate concerns as three different but related needs:</p>

<ol>
<li>Domain-specific data versioning techniques and tools.</li>
<li>Version Control Systems that leverage (1.) and track all separate versions.</li>
<li>Indexing services that (a) understand (2.) and provide access to the tracked versions, (b) but are agnostic to (1.).</li>
</ol>

<p>Separating these needs out provides clear tool scope. Existing or new Version Control Systems can handle (2.), independent of tools built to handle (1.). A Package Manager can handle (3.).</p>

<p>While git has achieved tremendous success and is currently the most popular version control system, history has shown that preferences shift as better tools emerge (git replaced svn, svn replaced cvs, etc). Unless it becomes abundantly clear that no new VCS would supplant current ones, it would be wise to build Package Managers independent and compatible with various VCSes.</p>

<blockquote>
<p>(6) A Data Package Manager would be independent of VCS.</p>
</blockquote>

<h3 id="formatting">Formatting</h3>

<p>The question of formats and conversions is formidable and worth lengthier discussion. For the purposes of this post, package managers would simplify three aspects: re-publishing, tooling, and automation.</p>

<h4 id="1.-reformat-and-republish">1. Reformat and Republish</h4>

<p>As <a href="#versioning">discussed above</a>, all versions of a dataset would be available. This includes versions that do not alter the data itself but change the format of the files themselves. Data formatting is a tedious process fraught with problems; valuable data worker time is spent parsing and converting data from one format to another. With a properly namespaced<sup id="fnref3"><a href="#fn3" rel="footnote">3</a></sup> package manager, end-users themselves could reformat and republish a new version of the dataset. This permits users to leverage each other&#39;s efforts and save broader community time.</p>

<blockquote>
<p>(7) A Data Package Manager would provide reformatted datasets.</p>
</blockquote>

<h4 id="2.-reformatting-tools">2. Reformatting Tools</h4>

<p>There exist thousands of tools to clean, convert, reformat, or otherwise modify datasets. A package manager could provide (a) programmable access to datasets, (b) dataset format information, and (c) standardized file layouts for particular formats. This would significantly simplify building these and other tools, as well as broaden their reach to other datasets outside of the authors&#39; knowledge.  The package manager is an infrastructure tool, a platform for other tools to leverage.</p>

<blockquote>
<p>(8) A Data Package Manager would enhance data processing tools.</p>
</blockquote>

<h4 id="3.-automating-processes">3. Automating Processes</h4>

<p>On the other hand, these provisions would also enable the package manager itself to automate particular processes for the sake of end users. For example, consider a set of interchangeable formats (e.g. encodings like {<code>JSON</code>, <code>XML</code>}, or {<code>matlab matrix</code>, <code>numpy array</code>}). Suppose these formats and their relationship are registered with the package manager, including bi-directional conversion tools. The package manager would then be able to convert any dataset from one format to another. This could be done either in the user&#39;s own machine, or remotely (e.g. publishing one format automatically produces projections into compatible formats<sup id="fnref4"><a href="#fn4" rel="footnote">4</a></sup>). End users need not be concerned with such simple reformats. Of course, other tasks beyond reformatting could be automated similarly.</p>

<blockquote>
<p>(9) A Data Package Manager would automate data processing tasks.</p>
</blockquote>

<h3 id="licensing">Licensing</h3>

<p>By requiring a license, a package manager would enforce dataset authors consider, learn about, and formalize the rights of their end users. Additionally, by encouraging particular licenses, it could guide authors towards more open and modification-friendly licensing. This would reduce ambiguity and <a href="/data/2014-02-21/data-management-vocabulary#forking-friction">forking friction</a>.</p>

<blockquote>
<p>(10) A Data Package Manager would encourage better licensing.</p>
</blockquote>

<h3 id="open-access">Open Access</h3>

<p>First, a package manager would improve <em>accessing</em> open-access datasets. Currently, it is common to find open-access repositories with many hurdles to retrieving its hosted files. A simple package manager interface would better the experience and save time. Also, a package manager would cover the costs and assuage the distribution concerns of authors and publishers.</p>

<p>Second, by reducing <a href="/data/2014-02-21/data-management-vocabulary#forking-friction">forking friction</a>, a package manager would greatly support modifying and republishing (forking) of datasets. This is precisely what <em>open access data</em> should .</p>

<p>An open Data Package Manager perfectly complements pre-print publication servers like <a href="http://arxiv.org">arXiv</a> and <a href="http://biorxiv.org">bioRxiv</a></p>

<blockquote>
<p>(11) A Data Package Manager would improve open access.</p>
</blockquote>

<h2 id="summary">Summary</h2>

<ol>
<li>A Package Manager can solve <a href="/data/2014-02-21/data-management-problems">our Data Management problems</a>.</li>
<li>It would amortize distribution costs.</li>
<li>It would index and search datasets.</li>
<li>It would provide datasets permanently.</li>
<li>It would provide all versions of datasets.</li>
<li>It would be independent of VCS.</li>
<li>It would provide reformatted datasets.</li>
<li>It would enhance data processing tools.</li>
<li>It would automate data processing tasks.</li>
<li>It would encourage better licensing.</li>
<li>It would improve open access.</li>
</ol>

<p>It is time to build one.</p>

<div class="align-center">
<img src="http://jbenet.static.s3.amazonaws.com/51cd6a8/data-flap.png" />
</div>

<!-- The multiplicity of software package managers is, perhaps, an issue in itself. Thankfully, generally there is one canonical package maneger per use case. Still, arguments can be made for a "Package Manager of Package Managers", or "One Package Manager to Manage Them All". Here are some examples:

- Operating System Packages:
  [apt (debian)](https://packages.debian.org),
  [apt (ubuntu)](https://packages.ubuntu.com),
  [rpm (redhat)](http://www.rpm.org),
  [brew (osx)](http://brew.sh).
- Source Code:
  [GitHub](https://github.com/),
  [Bitbucket](https://bitbucket.org/),
  [LaunchPad](http://launchpad.net/),
  [SourceForge](http://sourceforge.net/),
  [Google Code](http://code.google.com/).
- Language/Platforms:
  [PyPI (Python)](https://pypi.python.org/‎),
  [RubyGems (Ruby)](http://rubygems.org/‎),
  [npm (node)](https://www.npmjs.org/),
  [Cabal (Haskell)](http://www.haskell.org/cabal).
- Text Editors:
  [Emacs](http://marmalade-repo.org/),
  [SublimeText](https://sublime.wbond.net/‎),
  [Atom](https://atom.io/packages).
- App Stores:
  Apple ([Mac](http://en.wikipedia.org/wiki/Apple_App_Store),
         [iOS](http://en.wikipedia.org/wiki/App_Store_(iOS)));
  Google ([Android](https://play.google.com/store/apps‎),
          [Chrome](https://chrome.google.com/webstore));
  Microsoft ([Desktop](windows.microsoft.com/en-us/windows-8/apps‎),
             [Phone](www.windowsphone.com/en-us/store‎)).
-->

<div class="footnotes">
<hr>
<ol>

<li id="fn1">
<p>This is clearly the case in software: a package distributed on its own website is significantly less likely to survive than a package distributed through a mainstream software package manager (e.g. debian aptitude).&nbsp;<a href="#fnref1" rev="footnote">&#8617;</a></p>
</li>

<li id="fn2">
<p>Why <a href="http://git-scm.com">git</a> is not it (yet) is argued in a future post.&nbsp;<a href="#fnref2" rev="footnote">&#8617;</a></p>
</li>

<li id="fn3">
<p>Namespacing is important to reduce publication friction. This is similar to namespacing and forking on github.&nbsp;<a href="#fnref3" rev="footnote">&#8617;</a></p>
</li>

<li id="fn4">
<p>It&#39;s worth mentioning that such automatic reformatting at central repositories should occur <a href="http://en.wikipedia.org/wiki/Lazy_evaluation">lazily</a>.&nbsp;<a href="#fnref4" rev="footnote">&#8617;</a></p>
</li>

</ol>
</div>

</div>

  </div>


 <!-- Footer -->
  <footer>
    <div id="site-map">
      <h5>juan.benet.ai</h5>
      <ul class="links no-bullet">
        <li><a href="/">Home</a></li>
        <li><a href="/about">About</a></li>
      </ul>
    </div>
    <div id="contact-me">
      <h5>Contact</h5>
      <ul class="links no-bullet">
        <li><a href="https://twitter.com/intent/user?screen_name=juanbenet" target="_blank"><i class="icon-twitter"></i> @juanbenet</a></li>
        <li><a href="https://github.com/jbenet" id="new-issue" target="_blank"><i class="icon-github"></i> github.com/jbenet</a></li>
        <li>
        <a href="http://www.google.com/recaptcha/mailhide/d?k=01LaO8uNTV8Ss8kghGlxHXCw==&amp;c=eEwF2u87Cdkgipi5COLbnA=="
        onclick="window.open('http://www.google.com/recaptcha/mailhide/d?k\07501LaO8uNTV8Ss8kghGlxHXCw\75\75\46c\75eEwF2u87Cdkgipi5COLbnA\75\075', '', 'toolbar=0,scrollbars=0,location=0,statusbar=0,menubar=0,resizable=0,width=500,height=300'); return false;"
        title="Reveal this e-mail address"><i class="icon-envelope"></i>
        click-to-reveal@benet.ai</a>
        </li>
      </ul>
    </div>
  </footer>

</div>

<!-- cdnlibs -->
<script src="//cdnjs.cloudflare.com/ajax/libs/underscore.js/1.5.1/underscore-min.js"></script>
<script src="//netdna.bootstrapcdn.com/bootstrap/3.0.0/js/bootstrap.min.js"></script>
<script src="//netdna.bootstrapcdn.com/font-awesome/3.2.1/css/font-awesome.min.css"></script>

<script type="text/javascript">
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-48626381-1', 'benet.ai');
  ga('send', 'pageview');

</script>

<script type="text/javascript">
$(document).ready(function() {
  // Modify this template to add or change links.
  var links = _.template('\
    <div class="header-links">\
      <a href="#<%= id %>"><i class="icon icon-link"></i></a>\
    </div>\
  ');

  // If your headers dont already have ids, use this slug fn
  var slugize = function(title) {
    return title.toLowerCase()
      .replace(/[^\w ()]+/g,'')
      .replace(/ +/g,'-');
  }

  // Modify the ':header' selector to apply to other elems
  $(':header').each(function(i, h) {

    // Add an id, if it doesn't have one.
    if (!$(h).attr('id')) {
      var id = $(h).text().replace(/[^A-Za-z0-9_]+/g, '-')
      id = id.replace(/^-+|-+$/g, '')
      $(h).attr('id', slugize($(h).text()));
    }

    // Add the link div
    $(h).append($(links({
      id: $(h).attr('id')
    })));
  });
});
</script>

</body>
</html>
